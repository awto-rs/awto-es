"use strict";(self.webpackChunkthalo_docs=self.webpackChunkthalo_docs||[]).push([[386],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>m});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},g=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(t),g=o,m=p["".concat(l,".").concat(g)]||p[g]||u[g]||i;return t?a.createElement(m,r(r({ref:n},d),{},{components:t})):a.createElement(m,r({ref:n},d))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,r=new Array(i);r[0]=g;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[p]="string"==typeof e?e:o,r[1]=s;for(var c=2;c<i;c++)r[c]=t[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}g.displayName="MDXCreateElement"},4050:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=t(7462),o=(t(7294),t(3905));const i={sidebar_position:6},r="Projections and Event Handling",s={unversionedId:"projections-and-event-handling",id:"projections-and-event-handling",title:"Projections and Event Handling",description:"In Thalo, projections play a crucial role in listening to and handling events. They ensure an at-least-once delivery guarantee, maintaining the integrity and consistency of the system.",source:"@site/docs/projections-and-event-handling.md",sourceDirName:".",slug:"/projections-and-event-handling",permalink:"/thalo/docs/projections-and-event-handling",draft:!1,editUrl:"https://github.com/thalo-rs/thalo-docs/tree/main/packages/create-docusaurus/templates/shared/docs/projections-and-event-handling.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Event Store Management",permalink:"/thalo/docs/event-store-management"},next:{title:"Community and Support",permalink:"/thalo/docs/community-and-support"}},l={},c=[{value:"Understanding Projections",id:"understanding-projections",level:2},{value:"Implementing a Projection",id:"implementing-a-projection",level:2},{value:"Acknowledging Events",id:"acknowledging-events",level:2}],d={toc:c};function p(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"projections-and-event-handling"},"Projections and Event Handling"),(0,o.kt)("p",null,"In Thalo, projections play a crucial role in listening to and handling events. They ensure an at-least-once delivery guarantee, maintaining the integrity and consistency of the system."),(0,o.kt)("h2",{id:"understanding-projections"},"Understanding Projections"),(0,o.kt)("p",null,"A projection in Thalo is a component that listens for specific events and updates its state accordingly. It's typically used for creating read models or reacting to events in a certain way."),(0,o.kt)("h2",{id:"implementing-a-projection"},"Implementing a Projection"),(0,o.kt)("p",null,"Here's a basic outline for implementing a projection in Thalo:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    let mut last_global_id = None; // This would typically be stored in a database\n    let mut count = 0; // This is the projection state, and could be a row in a database\n\n    let mut client = ProjectionClient::connect("http://localhost:4433").await?;\n    let mut streaming = client\n        .subscribe_to_events(SubscriptionRequest {\n            name: "my_projection".to_string(),\n            events: vec![EventInterest {\n                category: "counter".to_string(),\n                event: "Incremented".to_string(),\n            }],\n        })\n        .await?\n        .into_inner();\n\n    while let Some(message) = streaming.message().await? {\n        if last_global_id.map_or(false, |last_global_id| message.global_id <= last_global_id) {\n            // Ignore, since we\'ve already handled this event.\n            // This logic keeps the projection idempotent, which is important since\n            // projections have an at-least-once guarantee, meaning if a connection issue\n            // occurs, we might reprocess event we\'ve already seen.\n            continue;\n        }\n\n        // Update the count\n        let event: Incremented = serde_json::from_str::<serde_json::Value>(&message.data)\n            .and_then(|payload| serde_json::from_value(json!({ message.msg_type: payload })))?;\n\n        count += event.amount;\n\n        // In a transaction, save both the projection state (count) and last global id in a database\n        last_global_id = Some(message.global_id);\n\n        // Acknowledge we\'ve handled this event\n        client\n            .acknowledge_event(Acknowledgement {\n                name: "my_projection".to_string(),\n                global_id: message.global_id,\n            })\n            .await?;\n    }\n\n    Ok(())\n}\n')),(0,o.kt)("p",null,"This example demonstrates subscribing to events, processing them, and acknowledging each event to ensure at-least-once delivery."),(0,o.kt)("h2",{id:"acknowledging-events"},"Acknowledging Events"),(0,o.kt)("p",null,"In Thalo, each projection is responsible for acknowledging the events it processes. This acknowledgement informs Thalo that the event has been handled, allowing the system to update the last acknowledged event position.\nIt's crucial for projections to implement idempotent behavior, as Thalo's at-least-once delivery guarantee means events might be delivered multiple times, especially in cases of connection issues or system failures. Properly acknowledging events ensures that Thalo maintains an accurate record of which events have been processed, enhancing the system's reliability and consistency."))}p.isMDXComponent=!0}}]);